---
title: Autentikasi Sederhana dengan Session & Bcrypt
---

## Materi: Pengetahuan & Konsep

Sejauh ini API kamu terbuka untuk siapa saja. Sesi 27 ini kita tambahkan **autentikasi sederhana**: user harus login dulu sebelum bisa akses endpoint tertentu (misalnya `POST/PUT/DELETE /api/books`).

Alur autentikasi dasar:

1. **Register**: user kirim username + password → backend hash password dengan **bcrypt** → simpan di tabel `users`.
2. **Login**: user kirim username + password → backend cek hash → jika cocok, simpan user info di **session** (pakai `express-session`).
3. **Protected routes**: endpoint tertentu cek apakah user sudah login via **middleware** → jika belum, reject dengan 401 Unauthorized.

Kenapa pakai session (bukan JWT):

- Lebih mudah dipahami untuk pemula: session ID disimpan di cookie, data session di server.
- Cocok untuk aplikasi monolith sederhana (frontend & backend di domain yang sama atau CORS diatur).

---

## Praktik: Langkah demi Langkah

### Langkah 1: Install dependencies

Di folder `backend/`:

```bash
npm install express-session bcrypt
```

- `express-session`: middleware untuk manage session.
- `bcrypt`: library untuk hash & verify password.

### Langkah 2: Tambahkan tabel `users` di `database.js`

Edit `backend/database.js`, tambahkan schema `users` setelah tabel `books`:

```js
const Database = require("better-sqlite3");
const path = require("path");

const dbPath = path.join(__dirname, "books.db");
const db = new Database(dbPath);

// Tabel books (sudah ada)
const createBooksTableSQL = `
  CREATE TABLE IF NOT EXISTS books (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    author TEXT NOT NULL,
    category TEXT,
    status TEXT DEFAULT 'DRAFT',
    price INTEGER DEFAULT 0,
    stock INTEGER DEFAULT 0
  )
`;

db.exec(createBooksTableSQL);

// Tabel users (baru)
const createUsersTableSQL = `
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TEXT DEFAULT (datetime('now'))
  )
`;

db.exec(createUsersTableSQL);
console.log("Database & tabel books + users siap.");

// Sample data books (sudah ada, biarkan saja)
const booksCount = db.prepare("SELECT COUNT(*) as count FROM books").get();
if (booksCount.count === 0) {
  // ... insert sample books
}

// Export database
module.exports = db;
```

### Langkah 3: Setup `express-session` di `server.js`

Tambahkan middleware session di `server.js`, setelah `app.use(express.json())`:

```js
const express = require("express");
const session = require("express-session");
const bcrypt = require("bcrypt");
const db = require("./database");

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware JSON
app.use(express.json());

// Middleware session
app.use(
  session({
    secret: "your-secret-key-change-this", // Ganti dengan string random untuk production
    resave: false,
    saveUninitialized: false,
    cookie: {
      maxAge: 1000 * 60 * 60 * 24, // 1 hari
      httpOnly: true,
    },
  }),
); // Pattern setup session[web:201][web:202][web:207]

// ... routes lainnya
```

Poin penting:

- `secret`: string untuk sign session ID cookie (harus unik & rahasia di production).
- `resave: false`, `saveUninitialized: false`: best practice untuk menghindari menyimpan session kosong.
- `cookie.maxAge`: durasi session (1 hari = 86400000 ms).

### Langkah 4: Buat endpoint `/api/register` dan `/api/login`

Tambahkan di `server.js` setelah route dasar:

```js
// POST /api/register - daftar user baru
app.post("/api/register", async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res.status(400).json({ error: "Username dan password wajib diisi" });
  }

  if (password.length < 6) {
    return res.status(400).json({ error: "Password minimal 6 karakter" });
  }

  try {
    // Hash password dengan bcrypt
    const saltRounds = 10;
    const passwordHash = await bcrypt.hash(password, saltRounds); // Pattern hash password[web:205][web:208]

    // Simpan ke database
    const insert = db.prepare(`
      INSERT INTO users (username, password_hash)
      VALUES (?, ?)
    `);

    const info = insert.run(username, passwordHash);

    res.status(201).json({
      message: "User berhasil didaftarkan",
      userId: info.lastInsertRowid,
    });
  } catch (err) {
    console.error(err);
    if (err.message.includes("UNIQUE constraint failed")) {
      return res.status(400).json({ error: "Username sudah dipakai" });
    }
    res.status(500).json({ error: "Database error" });
  }
});

// POST /api/login - login user
app.post("/api/login", async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res.status(400).json({ error: "Username dan password wajib diisi" });
  }

  try {
    // Cari user di database
    const user = db
      .prepare("SELECT * FROM users WHERE username = ?")
      .get(username);

    if (!user) {
      return res.status(401).json({ error: "Username atau password salah" });
    }

    // Verify password
    const isValid = await bcrypt.compare(password, user.password_hash); // Pattern verify password[web:205][web:208]

    if (!isValid) {
      return res.status(401).json({ error: "Username atau password salah" });
    }

    // Simpan user info di session
    req.session.userId = user.id;
    req.session.username = user.username; // Pattern set session[web:200][web:202][web:203]

    res.json({
      message: "Login berhasil",
      user: { id: user.id, username: user.username },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Server error" });
  }
});

// GET /api/logout - logout user
app.post("/api/logout", (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ error: "Gagal logout" });
    }
    res.json({ message: "Logout berhasil" });
  });
});

// GET /api/me - cek user yang sedang login
app.get("/api/me", (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: "Belum login" });
  }

  res.json({
    id: req.session.userId,
    username: req.session.username,
  });
});
```

### Langkah 5: Buat middleware `requireAuth` untuk protect routes

Tambahkan middleware sebelum routes books:

```js
// Middleware: cek apakah user sudah login
function requireAuth(req, res, next) {
  if (!req.session.userId) {
    return res.status(401).json({ error: "Unauthorized: silakan login" });
  }
  next();
} // Pattern auth middleware[web:206][web:209]

// Protect routes yang butuh autentikasi
// GET /api/books - tetap public (boleh akses tanpa login)
app.get("/api/books", (req, res) => {
  // ... (tidak berubah)
});

// POST /api/books - butuh login
app.post("/api/books", requireAuth, (req, res) => {
  // ... (tidak berubah)
});

// PUT /api/books/:id - butuh login
app.put("/api/books/:id", requireAuth, (req, res) => {
  // ... (tidak berubah)
});

// DELETE /api/books/:id - butuh login
app.delete("/api/books/:id", requireAuth, (req, res) => {
  // ... (tidak berubah)
});
```

Sekarang endpoint `POST`, `PUT`, `DELETE` hanya bisa diakses kalau user sudah login (punya session aktif).

### Langkah 6: Test manual dengan curl/Postman

1. **Register**:

   ```bash
   curl -X POST http://localhost:3000/api/register \
     -H "Content-Type: application/json" \
     -d '{"username":"admin","password":"admin123"}'
   ```

2. **Login** (simpan cookie session):

   ```bash
   curl -X POST http://localhost:3000/api/login \
     -H "Content-Type: application/json" \
     -d '{"username":"admin","password":"admin123"}' \
     -c cookies.txt
   ```

3. **Test POST books** (pakai cookie):

   ```bash
   curl -X POST http://localhost:3000/api/books \
     -H "Content-Type: application/json" \
     -b cookies.txt \
     -d '{"title":"Test Book","author":"Me"}'
   ```

   Tanpa cookie → error 401.

---

## Hasil Akhir

Setelah Sesi 27 ini:

- API punya sistem autentikasi sederhana dengan session & bcrypt.
- Endpoint `POST/PUT/DELETE` dilindungi middleware `requireAuth`.
- Password disimpan dengan aman (hashed, tidak plain text).
