---
title: Mengganti In-Memory Array dengan Database SQLite
---

## Materi: Pengetahuan & Konsep

Sejauh ini API kamu pakai **array in-memory** (`let books = [...]`), jadi data hilang setiap server restart.

Sesi ini kita ganti dengan **SQLite database** supaya data tersimpan permanen di file.

**SQLite dipilih karena :**

- **File-based**: tidak butuh server database terpisah (MySQL/PostgreSQL butuh install & run server), cukup satu file `.db`.
- **Mudah setup**: cocok untuk belajar dan aplikasi kecil/menengah.
- **SQL standar**: kamu belajar query SQL yang bisa ditransfer ke database lain.

Untuk library Node.js, kita pakai **`better-sqlite3`** (bukan `sqlite3`) karena:

- API **synchronous** yang lebih clean dan mudah dipahami (tidak perlu callback/promise untuk setiap query).
- **Lebih cepat** dari `sqlite3` di hampir semua benchmark.
- Cocok untuk Express API yang mayoritas operasinya singkat (CRUD sederhana).

---

## Praktik: Langkah demi Langkah

### Langkah 1: Install `better-sqlite3`

Di folder `backend/`:

```bash
npm install better-sqlite3
```

### Langkah 2: Buat file `database.js` untuk koneksi & schema

Buat file baru `backend/database.js`:

```js
const Database = require("better-sqlite3");
const path = require("path");

// Buat/buka file database
const dbPath = path.join(__dirname, "books.db");
const db = new Database(dbPath);

// Buat tabel books kalau belum ada
const createTableSQL = `
  CREATE TABLE IF NOT EXISTS books (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    author TEXT NOT NULL,
    category TEXT,
    status TEXT DEFAULT 'DRAFT',
    price INTEGER DEFAULT 0,
    stock INTEGER DEFAULT 0
  )
`;

db.exec(createTableSQL);
console.log("Database & tabel books siap.");

// Insert sample data kalau tabel masih kosong (opsional)
const count = db.prepare("SELECT COUNT(*) as count FROM books").get();
if (count.count === 0) {
  console.log("Memasukkan sample data...");
  const insert = db.prepare(`
    INSERT INTO books (title, author, category, status, price, stock)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

  insert.run(
    "Mastering Bulma",
    "Jeremy Thomas",
    "Design",
    "PUBLISHED",
    150000,
    25,
  );
  insert.run(
    "React for Beginners",
    "Some Author",
    "Programming",
    "DRAFT",
    175000,
    0,
  );
  console.log("Sample data inserted.");
}

// Export database instance
module.exports = db;
```

Poin penting dari pattern ini:

- `new Database(path)` membuat koneksi.
- `db.exec(sql)` untuk menjalankan DDL (CREATE TABLE).
- `db.prepare(sql)` untuk membuat prepared statement (aman dari SQL injection).
- `.run()` untuk INSERT/UPDATE/DELETE, `.get()` untuk SELECT satu row, `.all()` untuk SELECT banyak row.

### Langkah 3: Update `server.js` – ganti array dengan query database

Buka `backend/server.js`, **hapus array `books`**, lalu import database:

```js
const express = require("express");
const db = require("./database"); // Import database

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

// Route dasar
app.get("/", (req, res) => {
  res.json({ message: "Books API is running (with SQLite)" });
});

// GET /api/books - ambil semua buku
app.get("/api/books", (req, res) => {
  try {
    const books = db.prepare("SELECT * FROM books").all();
    res.json(books);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Database error" });
  }
});

// GET /api/books/:id - ambil 1 buku
app.get("/api/books/:id", (req, res) => {
  const id = Number(req.params.id);
  try {
    const book = db.prepare("SELECT * FROM books WHERE id = ?").get(id);
    if (!book) {
      return res.status(404).json({ error: "Book not found" });
    }
    res.json(book);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Database error" });
  }
});

// POST /api/books - tambah buku baru
app.post("/api/books", (req, res) => {
  const data = req.body;

  if (!data.title || !data.author) {
    return res.status(400).json({ error: "title dan author wajib diisi" });
  }

  try {
    const insert = db.prepare(`
      INSERT INTO books (title, author, category, status, price, stock)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    const info = insert.run(
      data.title,
      data.author,
      data.category || "",
      data.status || "DRAFT",
      data.price || 0,
      data.stock || 0,
    );

    // Ambil buku yang baru dibuat
    const newBook = db
      .prepare("SELECT * FROM books WHERE id = ?")
      .get(info.lastInsertRowid);

    res.status(201).json(newBook);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Database error" });
  }
});

// PUT /api/books/:id - update buku
app.put("/api/books/:id", (req, res) => {
  const id = Number(req.params.id);
  const data = req.body;

  try {
    // Cek apakah buku ada
    const existing = db.prepare("SELECT * FROM books WHERE id = ?").get(id);
    if (!existing) {
      return res.status(404).json({ error: "Book not found" });
    }

    const update = db.prepare(`
      UPDATE books
      SET title = ?, author = ?, category = ?, status = ?, price = ?, stock = ?
      WHERE id = ?
    `);

    update.run(
      data.title ?? existing.title,
      data.author ?? existing.author,
      data.category ?? existing.category,
      data.status ?? existing.status,
      data.price ?? existing.price,
      data.stock ?? existing.stock,
      id,
    );

    const updated = db.prepare("SELECT * FROM books WHERE id = ?").get(id);
    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Database error" });
  }
});

// DELETE /api/books/:id - hapus buku
app.delete("/api/books/:id", (req, res) => {
  const id = Number(req.params.id);

  try {
    const existing = db.prepare("SELECT * FROM books WHERE id = ?").get(id);
    if (!existing) {
      return res.status(404).json({ error: "Book not found" });
    }

    db.prepare("DELETE FROM books WHERE id = ?").run(id);
    res.status(204).send();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Database error" });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`Books API listening on port ${PORT}`);
});
```

Perubahan kunci dari in-memory ke database:

- Semua operasi pakai **prepared statement** dengan placeholder `?` untuk keamanan (mencegah SQL injection).
- `INSERT` mengembalikan `info.lastInsertRowid` untuk mendapat ID baru.
- `UPDATE` dan `DELETE` pakai `.run()`, `SELECT` pakai `.get()` (1 row) atau `.all()` (banyak).

### Langkah 4: Test ulang semua endpoint

Restart server:

```bash
npm start
```

Kamu akan lihat log:

```text
Database & tabel books siap.
Memasukkan sample data...
Sample data inserted.
Books API listening on port 3000
```

Cek file `books.db` muncul di folder `backend/`.

Test endpoint:

- `GET http://localhost:3000/api/books` → data sample muncul.
- `POST` → tambah buku baru, refresh GET → buku baru ada (dan tetap ada meskipun server restart!)
- `PUT` → update stock/price → berhasil persisten.
- `DELETE` → hapus buku → data benar-benar hilang dari database.

Frontend Bulma (`inventory.html`, `add-book.html`) tidak perlu diubah sama sekali karena API contract-nya sama (endpoint, JSON structure).

---

## Hasil Akhir

Setelah Sesi 26:

- Data buku sekarang **persisten** di file SQLite.
- API masih REST-compliant, frontend tidak perlu ubah kode.
- Kamu mulai paham SQL dasar (CREATE TABLE, INSERT, SELECT, UPDATE, DELETE) yang bisa ditransfer ke database lain.
